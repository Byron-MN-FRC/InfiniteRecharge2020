// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.InvertType;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.RemoteSensorSource;
import com.ctre.phoenix.motorcontrol.StatusFrame;
import com.ctre.phoenix.motorcontrol.SupplyCurrentLimitConfiguration;
import com.ctre.phoenix.motorcontrol.TalonFXInvertType;
import com.ctre.phoenix.motorcontrol.can.TalonFXConfiguration;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;
import com.ctre.phoenix.sensors.PigeonIMU;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.DoubleSolenoid.Value;
import edu.wpi.first.wpilibj.command.Subsystem;
import frc.robot.Constants;
import frc.robot.commands.driveWithJoyStick;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.Joystick;
import com.ctre.phoenix.sensors.PigeonIMU_StatusFrame;

/**
 *
 */
public class DriveTrain extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
private WPI_TalonFX leftSlaveFalcon;
private WPI_TalonFX rightSlaveFalcon;
private DoubleSolenoid shifter;
private PigeonIMU pigeon;
private WPI_TalonFX rightMasterFalcon;
private WPI_TalonFX leftMasterFalcon;
private DifferentialDrive tankDrive;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    double limitedJoystick = 0;
    private double y = 0;
    private double twist = 0;
    TalonFXInvertType _leftInvert = TalonFXInvertType.CounterClockwise; // Same as invert = "false"
    TalonFXInvertType _rightInvert = TalonFXInvertType.Clockwise; // Same as invert = "true"
    TalonFXConfiguration _leftConfig = new TalonFXConfiguration();
    TalonFXConfiguration _rightConfig = new TalonFXConfiguration();

    public DriveTrain() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
leftSlaveFalcon = new WPI_TalonFX(0);


        
rightSlaveFalcon = new WPI_TalonFX(2);


        
shifter = new DoubleSolenoid(10, 2, 4);
addChild("shifter",shifter);

        
pigeon = new PigeonIMU(4);


        
rightMasterFalcon = new WPI_TalonFX(3);


        
leftMasterFalcon = new WPI_TalonFX(1);


        
tankDrive = new DifferentialDrive(leftMasterFalcon, rightMasterFalcon);
addChild("TankDrive",tankDrive);
tankDrive.setSafetyEnabled(true);
tankDrive.setExpiration(0.1);
tankDrive.setMaxOutput(1.0);

        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
      //  motorConfig();
    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new driveWithJoyStick());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop
        SmartDashboard.putNumber("Right Temp", rightMasterFalcon.getTemperature());
		SmartDashboard.putNumber("Right Stator Amps", rightMasterFalcon.getStatorCurrent());
		SmartDashboard.putNumber("Right Input Amps", rightMasterFalcon.getSupplyCurrent());
		SmartDashboard.putNumber("Left Temp", leftMasterFalcon.getTemperature());
		SmartDashboard.putNumber("Left Stator Amps", leftMasterFalcon.getStatorCurrent());
        SmartDashboard.putNumber("Left Input Amps", leftMasterFalcon.getSupplyCurrent());
        // SmartDashboard.putNumber("Left encoder", leftMasterFalcon.getSensorCollection().getIntegratedSensorPosition());
		// SmartDashboard.putNumber( "Left velocity", leftMasterFalcon.getSensorCollection().getIntegratedSensorVelocity());
		// SmartDashboard.putNumber("Right encoder", rightMasterFalcon.getSensorCollection().getIntegratedSensorPosition());
		// SmartDashboard.putNumber("Right velocity", rightMasterFalcon.getSensorCollection().getIntegratedSensorVelocity());

    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS
    public void driveWithJoystick(Joystick joystickP0) {
        y = -joystickP0.getY();
        twist = joystickP0.getTwist();
        double change = y - limitedJoystick;
        if (change > 0.01) {
            change = 0.01;
        } else if (change < -0.01) {
            change = -0.01;
        }
        limitedJoystick += change;
        tankDrive.arcadeDrive(limitedJoystick, -twist);
    }

    public void motorConfig() {
        motorConfigFalcon();
        // rightSlaveFalcon.follow(rightMasterFalcon);
        // rightMasterFalcon.setInverted(false);
        // rightSlaveFalcon.setInverted(InvertType.FollowMaster);
        // leftSlaveFalcon.follow(leftMasterFalcon);
        // // leftMasterFalcon.setInverted(true);
        // // leftSlaveFalcon.setInverted(false);
        // leftSlaveFalcon.setInverted(InvertType.FollowMaster);
    }

    public void driveForward() {
        rightMasterFalcon.set(.3);
        leftMasterFalcon.set(.3);
    }

    public void stop() {
        rightMasterFalcon.set(0);
        leftMasterFalcon.set(0);
    }

    public void shiftUp() {
        shifter.set(Value.kForward);
    }

    public void shiftDown() {
        shifter.set(Value.kReverse);
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public final SupplyCurrentLimitConfiguration currentLimitingFalcons = new SupplyCurrentLimitConfiguration(Constants.enable, SmartDashboard.getNumber(Constants.kAmpLimitStr,2), SmartDashboard.getNumber(Constants.kAmpPeakStr, 3), Constants.threshholdTime);
 
    public void motorConfigFalcon() {
        rightMasterFalcon.configSupplyCurrentLimit(currentLimitingFalcons);
        // Set Neutral Mode
        leftMasterFalcon.setNeutralMode(NeutralMode.Brake);
        leftSlaveFalcon.setNeutralMode(NeutralMode.Brake);
        rightMasterFalcon.setNeutralMode(NeutralMode.Brake);
        rightSlaveFalcon.setNeutralMode(NeutralMode.Brake);
        // Configure output and sensor direction
        leftMasterFalcon.setInverted(_leftInvert);
        leftSlaveFalcon.setInverted(_leftInvert);
        rightMasterFalcon.setInverted(_rightInvert);
        rightSlaveFalcon.setInverted(_rightInvert);
        // Reset Pigeon Configs
        pigeon.configFactoryDefault();
        // Feedback Sensor Configuration
        // Distance Configs
        // Configure the left Talon's selected sensor as integrated sensor
        _leftConfig.primaryPID.selectedFeedbackSensor = FeedbackDevice.IntegratedSensor; // Local Feedback Source

        // * Configure the Remote (Left) Talon's selected sensor as a remote sensor for
        // * the right Talon

        _rightConfig.remoteFilter0.remoteSensorDeviceID = leftMasterFalcon.getDeviceID(); // Device ID of Remote Source
        _rightConfig.remoteFilter0.remoteSensorSource = RemoteSensorSource.TalonSRX_SelectedSensor; // Remote Source
                                                                                                    // Type

        // * Now that the Left sensor can be used by the master Talon, set up the Left
        // * (Aux) and Right (Master) distance into a single Robot distance as the
        // * Master's Selected Sensor 0.

        setRobotDistanceConfigs(_rightInvert, _rightConfig);
        // FPID for Distance
        _rightConfig.slot0.kF = Constants.kGains_Distanc.kF;
        _rightConfig.slot0.kP = Constants.kGains_Distanc.kP;
        _rightConfig.slot0.kI = Constants.kGains_Distanc.kI;
        _rightConfig.slot0.kD = Constants.kGains_Distanc.kD;
        _rightConfig.slot0.integralZone = Constants.kGains_Distanc.kIzone;
        _rightConfig.slot0.closedLoopPeakOutput = Constants.kGains_Distanc.kPeakOutput;
        // * Heading Configs
        _rightConfig.remoteFilter1.remoteSensorDeviceID = pigeon.getDeviceID(); // Pigeon Device ID
        _rightConfig.remoteFilter1.remoteSensorSource = RemoteSensorSource.Pigeon_Yaw; // This is for a Pigeon over CAN
        _rightConfig.auxiliaryPID.selectedFeedbackSensor = FeedbackDevice.RemoteSensor1; // Set as the Aux Sensor
        _rightConfig.auxiliaryPID.selectedFeedbackCoefficient = 3600.0 / Constants.kPigeonUnitsPerRotation; // Convert
                                                                                                            // Yaw to
                                                                                                            // tenths of
                                                                                                            // a degree

        // * false means talon's local output is PID0 + PID1, and other side Talon is
        // PID0
        // * - PID1 This is typical when the master is the right Talon FX and using
        // Pigeon
        // *
        // * true means talon's local output is PID0 - PID1, and other side Talon is
        // PID0
        // * + PID1 This is typical when the master is the left Talon FX and using
        // Pigeon

        _rightConfig.auxPIDPolarity = false;
        // FPID for Heading
        _rightConfig.slot1.kF = Constants.kGains_Turning.kF;
        _rightConfig.slot1.kP = Constants.kGains_Turning.kP;
        _rightConfig.slot1.kI = Constants.kGains_Turning.kI;
        _rightConfig.slot1.kD = Constants.kGains_Turning.kD;
        _rightConfig.slot1.integralZone = Constants.kGains_Turning.kIzone;
        _rightConfig.slot1.closedLoopPeakOutput = Constants.kGains_Turning.kPeakOutput;
        // Config the neutral deadband.
        _leftConfig.neutralDeadband = Constants.kNeutralDeadband;
        _rightConfig.neutralDeadband = Constants.kNeutralDeadband;
        // *
        // * 1ms per loop. PID loop can be slowed down if need be. For example, - if
        // * sensor updates are too slow - sensor deltas are very small per update, so
        // * derivative error never gets large enough to be useful. - sensor movement is
        // * very slow causing the derivative error to be near zero.

        int closedLoopTimeMs = 1;
        rightMasterFalcon.configClosedLoopPeriod(0, closedLoopTimeMs, Constants.kTimeoutMs);
        rightMasterFalcon.configClosedLoopPeriod(1, closedLoopTimeMs, Constants.kTimeoutMs);
        // Motion Magic Configs
        _rightConfig.motionAcceleration = 2000; // (distance units per 100 ms) per second
        _rightConfig.motionCruiseVelocity = 2000; // distance units per 100 ms
        // APPLY the config settings
        leftMasterFalcon.configAllSettings(_leftConfig);
        leftSlaveFalcon.configAllSettings(_leftConfig);
        rightMasterFalcon.configAllSettings(_rightConfig);
        rightSlaveFalcon.configAllSettings(_rightConfig);
        // Set status frame periods to ensure we don't have stale data

        // * These aren't configs (they're not persistant) so we can set these after the
        // * configs.

        rightMasterFalcon.setStatusFramePeriod(StatusFrame.Status_12_Feedback1, 20, Constants.kTimeoutMs);
        rightMasterFalcon.setStatusFramePeriod(StatusFrame.Status_13_Base_PIDF0, 20, Constants.kTimeoutMs);
        rightMasterFalcon.setStatusFramePeriod(StatusFrame.Status_14_Turn_PIDF1, 20, Constants.kTimeoutMs);
        rightMasterFalcon.setStatusFramePeriod(StatusFrame.Status_10_Targets, 10, Constants.kTimeoutMs);
        leftMasterFalcon.setStatusFramePeriod(StatusFrame.Status_2_Feedback0, 5, Constants.kTimeoutMs);
        pigeon.setStatusFramePeriod(PigeonIMU_StatusFrame.CondStatus_9_SixDeg_YPR, 5, Constants.kTimeoutMs);
        // artificial limit for testing
        double max = 0.2;
        leftMasterFalcon.configPeakOutputForward(max, Constants.kTimeoutMs);
        leftMasterFalcon.configPeakOutputReverse(-max, Constants.kTimeoutMs);
        rightMasterFalcon.configPeakOutputForward(max, Constants.kTimeoutMs);
        rightMasterFalcon.configPeakOutputReverse(-max, Constants.kTimeoutMs);
        // WPI drivetrain classes assume by default left & right are opposite
        // - call this to apply + to both sides when moving forward
        tankDrive.setRightSideInverted(false);
        // set on call from autonomous
        rightMasterFalcon.selectProfileSlot(Constants.kSlot_Distanc, Constants.PID_PRIMARY);
        rightMasterFalcon.selectProfileSlot(Constants.kSlot_Turning, Constants.PID_TURN);
        rightSlaveFalcon.follow(rightMasterFalcon);
        leftSlaveFalcon.follow(leftMasterFalcon);
        zeroSensors();
        // rightMasterFalcon.configStatorCurrentLimit(currLimitCfg)
        // (Constants.kPeakCurrentAmps, Constants.kTimeoutMs);
        // rightMasterFalcon.configPeakCurrentDuration(Constants.kPeakTimeMs,
        // Constants.kTimeoutMs);
        // rightMasterFalcon.configContinuousCurrentLimit(Constants.kContinCurrentAmps,
        // Constants.kTimeoutMs);
        // rightMasterFalcon.enableCurrentLimit(_currentLimEn); // Honor initial setting
    }

    /** Zero all sensors, both Talons and Pigeon */
    public void zeroSensors() {
        SupplyCurrentLimitConfiguration changeLimit = new SupplyCurrentLimitConfiguration(Constants.enable, SmartDashboard.getNumber(Constants.kAmpLimitStr,2), SmartDashboard.getNumber(Constants.kAmpPeakStr, 3), Constants.threshholdTime);
		rightMasterFalcon.configSupplyCurrentLimit(changeLimit);
        leftMasterFalcon.getSensorCollection().setIntegratedSensorPosition(0, Constants.kTimeoutMs);
        rightMasterFalcon.getSensorCollection().setIntegratedSensorPosition(0, Constants.kTimeoutMs);
        pigeon.setYaw(0, Constants.kTimeoutMs);
        pigeon.setAccumZAngle(0, Constants.kTimeoutMs);
        System.out.println("Integrated Encoders + Pigeon] All sensors are zeroed.\n");
    }

    void setRobotDistanceConfigs(TalonFXInvertType masterInvertType, TalonFXConfiguration masterConfig) {
		/**
		 * Determine if we need a Sum or Difference.
		 * 
		 * The auxiliary Talon FX will always be positive in the forward direction
		 * because it's a selected sensor over the CAN bus.
		 * 
		 * The master's native integrated sensor may not always be positive when forward
		 * because sensor phase is only applied to *Selected Sensors*, not native sensor
		 * sources. And we need the native to be combined with the aux (other side's)
		 * distance into a single robot distance.
		 */

		/*
		 * THIS FUNCTION should not need to be modified. This setup will work regardless
		 * of whether the master is on the Right or Left side since it only deals with
		 * distance magnitude.
		 */

		/* Check if we're inverted */
		if (masterInvertType == TalonFXInvertType.Clockwise) {
			/*
			 * If master is inverted, that means the integrated sensor will be negative in
			 * the forward direction.
			 * 
			 * If master is inverted, the final sum/diff result will also be inverted. This
			 * is how Talon FX corrects the sensor phase when inverting the motor direction.
			 * This inversion applies to the *Selected Sensor*, not the native value.
			 * 
			 * Will a sensor sum or difference give us a positive total magnitude?
			 * 
			 * Remember the Master is one side of your drivetrain distance and Auxiliary is
			 * the other side's distance.
			 * 
			 * Phase | Term 0 | Term 1 | Result Sum: -1 *((-)Master + (+)Aux )| NOT OK, will
			 * cancel each other out Diff: -1 *((-)Master - (+)Aux )| OK - This is what we
			 * want, magnitude will be correct and positive. Diff: -1 *((+)Aux - (-)Master)|
			 * NOT OK, magnitude will be correct but negative
			 */

			masterConfig.diff0Term = FeedbackDevice.IntegratedSensor; // Local Integrated Sensor
			masterConfig.diff1Term = FeedbackDevice.RemoteSensor0; // Aux Selected Sensor
			masterConfig.primaryPID.selectedFeedbackSensor = FeedbackDevice.SensorDifference; // Diff0 - Diff1
		} else {
			/* Master is not inverted, both sides are positive so we can sum them. */
			masterConfig.sum0Term = FeedbackDevice.RemoteSensor0; // Aux Selected Sensor
			masterConfig.sum1Term = FeedbackDevice.IntegratedSensor; // Local IntegratedSensor
			masterConfig.primaryPID.selectedFeedbackSensor = FeedbackDevice.SensorSum; // Sum0 + Sum1
		}

		/*
		 * Since the Distance is the sum of the two sides, divide by 2 so the total
		 * isn't double the real-world value
		 */
		masterConfig.primaryPID.selectedFeedbackCoefficient = 0.5;
    }
    
}
